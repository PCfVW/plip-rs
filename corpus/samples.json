{
  "metadata": {
    "description": "PLIP corpus: semantically paired Python/Rust code samples",
    "version": "1.0.0",
    "created": "2026-01-29",
    "author": "Eric Jacopin",
    "categories": ["basic", "algorithms", "data_structures", "strings", "numeric"],
    "samples_per_language": 50,
    "pairing": "Each Python sample has a semantically equivalent Rust counterpart"
  },
  "samples": [
    {"code": "def hello():\n    print(\"Hello, World!\")", "language": "python"},
    {"code": "fn hello() {\n    println!(\"Hello, World!\");\n}", "language": "rust"},

    {"code": "def add(a, b):\n    return a + b", "language": "python"},
    {"code": "fn add(a: i32, b: i32) -> i32 {\n    a + b\n}", "language": "rust"},

    {"code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)", "language": "python"},
    {"code": "fn factorial(n: u64) -> u64 {\n    if n <= 1 {\n        1\n    } else {\n        n * factorial(n - 1)\n    }\n}", "language": "rust"},

    {"code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)", "language": "python"},
    {"code": "fn fibonacci(n: u32) -> u32 {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}", "language": "rust"},

    {"code": "def is_even(n):\n    return n % 2 == 0", "language": "python"},
    {"code": "fn is_even(n: i32) -> bool {\n    n % 2 == 0\n}", "language": "rust"},

    {"code": "def max_of_two(a, b):\n    if a > b:\n        return a\n    return b", "language": "python"},
    {"code": "fn max_of_two(a: i32, b: i32) -> i32 {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}", "language": "rust"},

    {"code": "def absolute(n):\n    if n < 0:\n        return -n\n    return n", "language": "python"},
    {"code": "fn absolute(n: i32) -> i32 {\n    if n < 0 {\n        -n\n    } else {\n        n\n    }\n}", "language": "rust"},

    {"code": "def power(base, exp):\n    result = 1\n    for _ in range(exp):\n        result *= base\n    return result", "language": "python"},
    {"code": "fn power(base: i32, exp: u32) -> i32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}", "language": "rust"},

    {"code": "def sum_range(n):\n    total = 0\n    for i in range(n + 1):\n        total += i\n    return total", "language": "python"},
    {"code": "fn sum_range(n: i32) -> i32 {\n    let mut total = 0;\n    for i in 0..=n {\n        total += i;\n    }\n    total\n}", "language": "rust"},

    {"code": "def count_digits(n):\n    count = 0\n    while n > 0:\n        n //= 10\n        count += 1\n    return count", "language": "python"},
    {"code": "fn count_digits(mut n: u32) -> u32 {\n    let mut count = 0;\n    while n > 0 {\n        n /= 10;\n        count += 1;\n    }\n    count\n}", "language": "rust"},

    {"code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "language": "python"},
    {"code": "fn binary_search(arr: &[i32], target: i32) -> Option<usize> {\n    let mut left = 0;\n    let mut right = arr.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if arr[mid] == target {\n            return Some(mid);\n        } else if arr[mid] < target {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    None\n}", "language": "rust"},

    {"code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr", "language": "python"},
    {"code": "fn bubble_sort(arr: &mut [i32]) {\n    let n = arr.len();\n    for i in 0..n {\n        for j in 0..n - i - 1 {\n            if arr[j] > arr[j + 1] {\n                arr.swap(j, j + 1);\n            }\n        }\n    }\n}", "language": "rust"},

    {"code": "def linear_search(arr, target):\n    for i, val in enumerate(arr):\n        if val == target:\n            return i\n    return -1", "language": "python"},
    {"code": "fn linear_search(arr: &[i32], target: i32) -> Option<usize> {\n    for (i, &val) in arr.iter().enumerate() {\n        if val == target {\n            return Some(i);\n        }\n    }\n    None\n}", "language": "rust"},

    {"code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a", "language": "python"},
    {"code": "fn gcd(mut a: u32, mut b: u32) -> u32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}", "language": "rust"},

    {"code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "language": "python"},
    {"code": "fn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let sqrt = (n as f64).sqrt() as u32;\n    for i in 2..=sqrt {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}", "language": "rust"},

    {"code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr", "language": "python"},
    {"code": "fn insertion_sort(arr: &mut [i32]) {\n    for i in 1..arr.len() {\n        let key = arr[i];\n        let mut j = i;\n        while j > 0 && arr[j - 1] > key {\n            arr[j] = arr[j - 1];\n            j -= 1;\n        }\n        arr[j] = key;\n    }\n}", "language": "rust"},

    {"code": "def selection_sort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr", "language": "python"},
    {"code": "fn selection_sort(arr: &mut [i32]) {\n    let n = arr.len();\n    for i in 0..n {\n        let mut min_idx = i;\n        for j in i + 1..n {\n            if arr[j] < arr[min_idx] {\n                min_idx = j;\n            }\n        }\n        arr.swap(i, min_idx);\n    }\n}", "language": "rust"},

    {"code": "def quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)", "language": "python"},
    {"code": "fn quicksort(arr: &mut [i32]) {\n    if arr.len() <= 1 {\n        return;\n    }\n    let pivot = arr[arr.len() / 2];\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left <= right {\n        while arr[left] < pivot { left += 1; }\n        while arr[right] > pivot { right -= 1; }\n        if left <= right {\n            arr.swap(left, right);\n            left += 1;\n            if right > 0 { right -= 1; }\n        }\n    }\n}", "language": "rust"},

    {"code": "class Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        return self.items.pop() if self.items else None\n    \n    def is_empty(self):\n        return len(self.items) == 0", "language": "python"},
    {"code": "struct Stack<T> {\n    items: Vec<T>,\n}\n\nimpl<T> Stack<T> {\n    fn new() -> Self {\n        Stack { items: Vec::new() }\n    }\n    \n    fn push(&mut self, item: T) {\n        self.items.push(item);\n    }\n    \n    fn pop(&mut self) -> Option<T> {\n        self.items.pop()\n    }\n    \n    fn is_empty(&self) -> bool {\n        self.items.is_empty()\n    }\n}", "language": "rust"},

    {"code": "class Queue:\n    def __init__(self):\n        self.items = []\n    \n    def enqueue(self, item):\n        self.items.append(item)\n    \n    def dequeue(self):\n        return self.items.pop(0) if self.items else None\n    \n    def is_empty(self):\n        return len(self.items) == 0", "language": "python"},
    {"code": "struct Queue<T> {\n    items: Vec<T>,\n}\n\nimpl<T> Queue<T> {\n    fn new() -> Self {\n        Queue { items: Vec::new() }\n    }\n    \n    fn enqueue(&mut self, item: T) {\n        self.items.push(item);\n    }\n    \n    fn dequeue(&mut self) -> Option<T> {\n        if self.items.is_empty() {\n            None\n        } else {\n            Some(self.items.remove(0))\n        }\n    }\n    \n    fn is_empty(&self) -> bool {\n        self.items.is_empty()\n    }\n}", "language": "rust"},

    {"code": "def find_max(arr):\n    if not arr:\n        return None\n    max_val = arr[0]\n    for val in arr[1:]:\n        if val > max_val:\n            max_val = val\n    return max_val", "language": "python"},
    {"code": "fn find_max(arr: &[i32]) -> Option<i32> {\n    if arr.is_empty() {\n        return None;\n    }\n    let mut max_val = arr[0];\n    for &val in &arr[1..] {\n        if val > max_val {\n            max_val = val;\n        }\n    }\n    Some(max_val)\n}", "language": "rust"},

    {"code": "def find_min(arr):\n    if not arr:\n        return None\n    min_val = arr[0]\n    for val in arr[1:]:\n        if val < min_val:\n            min_val = val\n    return min_val", "language": "python"},
    {"code": "fn find_min(arr: &[i32]) -> Option<i32> {\n    if arr.is_empty() {\n        return None;\n    }\n    let mut min_val = arr[0];\n    for &val in &arr[1..] {\n        if val < min_val {\n            min_val = val;\n        }\n    }\n    Some(min_val)\n}", "language": "rust"},

    {"code": "def sum_array(arr):\n    total = 0\n    for val in arr:\n        total += val\n    return total", "language": "python"},
    {"code": "fn sum_array(arr: &[i32]) -> i32 {\n    let mut total = 0;\n    for &val in arr {\n        total += val;\n    }\n    total\n}", "language": "rust"},

    {"code": "def average(arr):\n    if not arr:\n        return 0.0\n    return sum(arr) / len(arr)", "language": "python"},
    {"code": "fn average(arr: &[f64]) -> f64 {\n    if arr.is_empty() {\n        return 0.0;\n    }\n    arr.iter().sum::<f64>() / arr.len() as f64\n}", "language": "rust"},

    {"code": "def reverse_array(arr):\n    result = []\n    for i in range(len(arr) - 1, -1, -1):\n        result.append(arr[i])\n    return result", "language": "python"},
    {"code": "fn reverse_array(arr: &[i32]) -> Vec<i32> {\n    let mut result = Vec::new();\n    for i in (0..arr.len()).rev() {\n        result.push(arr[i]);\n    }\n    result\n}", "language": "rust"},

    {"code": "def count_occurrences(arr, target):\n    count = 0\n    for val in arr:\n        if val == target:\n            count += 1\n    return count", "language": "python"},
    {"code": "fn count_occurrences(arr: &[i32], target: i32) -> usize {\n    let mut count = 0;\n    for &val in arr {\n        if val == target {\n            count += 1;\n        }\n    }\n    count\n}", "language": "rust"},

    {"code": "def remove_duplicates(arr):\n    seen = set()\n    result = []\n    for val in arr:\n        if val not in seen:\n            seen.add(val)\n            result.append(val)\n    return result", "language": "python"},
    {"code": "fn remove_duplicates(arr: &[i32]) -> Vec<i32> {\n    let mut seen = std::collections::HashSet::new();\n    let mut result = Vec::new();\n    for &val in arr {\n        if seen.insert(val) {\n            result.push(val);\n        }\n    }\n    result\n}", "language": "rust"},

    {"code": "def reverse_string(s):\n    return s[::-1]", "language": "python"},
    {"code": "fn reverse_string(s: &str) -> String {\n    s.chars().rev().collect()\n}", "language": "rust"},

    {"code": "def is_palindrome(s):\n    return s == s[::-1]", "language": "python"},
    {"code": "fn is_palindrome(s: &str) -> bool {\n    let chars: Vec<char> = s.chars().collect();\n    let reversed: String = chars.iter().rev().collect();\n    s == reversed\n}", "language": "rust"},

    {"code": "def count_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count", "language": "python"},
    {"code": "fn count_vowels(s: &str) -> usize {\n    let vowels = \"aeiouAEIOU\";\n    let mut count = 0;\n    for c in s.chars() {\n        if vowels.contains(c) {\n            count += 1;\n        }\n    }\n    count\n}", "language": "rust"},

    {"code": "def to_uppercase(s):\n    return s.upper()", "language": "python"},
    {"code": "fn to_uppercase(s: &str) -> String {\n    s.to_uppercase()\n}", "language": "rust"},

    {"code": "def to_lowercase(s):\n    return s.lower()", "language": "python"},
    {"code": "fn to_lowercase(s: &str) -> String {\n    s.to_lowercase()\n}", "language": "rust"},

    {"code": "def word_count(s):\n    return len(s.split())", "language": "python"},
    {"code": "fn word_count(s: &str) -> usize {\n    s.split_whitespace().count()\n}", "language": "rust"},

    {"code": "def char_frequency(s):\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    return freq", "language": "python"},
    {"code": "fn char_frequency(s: &str) -> std::collections::HashMap<char, usize> {\n    let mut freq = std::collections::HashMap::new();\n    for c in s.chars() {\n        *freq.entry(c).or_insert(0) += 1;\n    }\n    freq\n}", "language": "rust"},

    {"code": "def first_non_repeating(s):\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    for char in s:\n        if freq[char] == 1:\n            return char\n    return None", "language": "python"},
    {"code": "fn first_non_repeating(s: &str) -> Option<char> {\n    let mut freq = std::collections::HashMap::new();\n    for c in s.chars() {\n        *freq.entry(c).or_insert(0) += 1;\n    }\n    for c in s.chars() {\n        if freq[&c] == 1 {\n            return Some(c);\n        }\n    }\n    None\n}", "language": "rust"},

    {"code": "def is_anagram(s1, s2):\n    return sorted(s1) == sorted(s2)", "language": "python"},
    {"code": "fn is_anagram(s1: &str, s2: &str) -> bool {\n    let mut chars1: Vec<char> = s1.chars().collect();\n    let mut chars2: Vec<char> = s2.chars().collect();\n    chars1.sort();\n    chars2.sort();\n    chars1 == chars2\n}", "language": "rust"},

    {"code": "def longest_word(s):\n    words = s.split()\n    if not words:\n        return \"\"\n    longest = words[0]\n    for word in words[1:]:\n        if len(word) > len(longest):\n            longest = word\n    return longest", "language": "python"},
    {"code": "fn longest_word(s: &str) -> &str {\n    let mut longest = \"\";\n    for word in s.split_whitespace() {\n        if word.len() > longest.len() {\n            longest = word;\n        }\n    }\n    longest\n}", "language": "rust"},

    {"code": "def square(n):\n    return n * n", "language": "python"},
    {"code": "fn square(n: i32) -> i32 {\n    n * n\n}", "language": "rust"},

    {"code": "def cube(n):\n    return n * n * n", "language": "python"},
    {"code": "fn cube(n: i32) -> i32 {\n    n * n * n\n}", "language": "rust"},

    {"code": "def celsius_to_fahrenheit(c):\n    return c * 9 / 5 + 32", "language": "python"},
    {"code": "fn celsius_to_fahrenheit(c: f64) -> f64 {\n    c * 9.0 / 5.0 + 32.0\n}", "language": "rust"},

    {"code": "def fahrenheit_to_celsius(f):\n    return (f - 32) * 5 / 9", "language": "python"},
    {"code": "fn fahrenheit_to_celsius(f: f64) -> f64 {\n    (f - 32.0) * 5.0 / 9.0\n}", "language": "rust"},

    {"code": "def circle_area(radius):\n    import math\n    return math.pi * radius * radius", "language": "python"},
    {"code": "fn circle_area(radius: f64) -> f64 {\n    std::f64::consts::PI * radius * radius\n}", "language": "rust"},

    {"code": "def rectangle_area(width, height):\n    return width * height", "language": "python"},
    {"code": "fn rectangle_area(width: f64, height: f64) -> f64 {\n    width * height\n}", "language": "rust"},

    {"code": "def triangle_area(base, height):\n    return 0.5 * base * height", "language": "python"},
    {"code": "fn triangle_area(base: f64, height: f64) -> f64 {\n    0.5 * base * height\n}", "language": "rust"},

    {"code": "def distance(x1, y1, x2, y2):\n    import math\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "language": "python"},
    {"code": "fn distance(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {\n    ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt()\n}", "language": "rust"},

    {"code": "def clamp(value, min_val, max_val):\n    if value < min_val:\n        return min_val\n    if value > max_val:\n        return max_val\n    return value", "language": "python"},
    {"code": "fn clamp(value: i32, min_val: i32, max_val: i32) -> i32 {\n    if value < min_val {\n        min_val\n    } else if value > max_val {\n        max_val\n    } else {\n        value\n    }\n}", "language": "rust"},

    {"code": "def lerp(a, b, t):\n    return a + (b - a) * t", "language": "python"},
    {"code": "fn lerp(a: f64, b: f64, t: f64) -> f64 {\n    a + (b - a) * t\n}", "language": "rust"}
  ]
}
