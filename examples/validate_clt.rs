//! Validate plip-rs CLT encoding against Python reference.
//!
//! **CLT Infrastructure** — loads reference data generated by `scripts/clt_reference.py`,
//! encodes the same residual vectors with `clt.rs`, and compares
//! top-10 features.
//!
//! Acceptance criterion (§7.3): top-10 features agree on ≥8/10 per test case.
//!
//! Usage:
//!   python `scripts/clt_reference.py`          # generate reference (once)
//!   cargo run --release --example `validate_clt`

#![allow(clippy::doc_markdown)]

use anyhow::{Context, Result};
use candle_core::{Device, Tensor};
use plip_rs::CrossLayerTranscoder;

#[derive(serde::Deserialize)]
struct ReferenceData {
    clt_repo: String,
    d_model: usize,
    n_features_per_layer: usize,
    test_cases: Vec<TestCase>,
}

#[derive(serde::Deserialize)]
struct TestCase {
    layer: usize,
    seed: usize,
    residual: Vec<f32>,
    n_active: usize,
    top_10: Vec<FeatureRef>,
}

#[derive(serde::Deserialize)]
struct FeatureRef {
    index: usize,
    activation: f32,
}

fn main() -> Result<()> {
    tracing_subscriber::fmt::init();

    let device = Device::cuda_if_available(0)?;
    println!("Device: {device:?}");

    // Load reference data
    let ref_path = "scripts/clt_reference_426k.json";
    let ref_text = std::fs::read_to_string(ref_path).with_context(|| {
        format!("Failed to read {ref_path}. Run: python scripts/clt_reference.py")
    })?;
    let ref_data: ReferenceData = serde_json::from_str(&ref_text)?;

    println!(
        "Reference: {} (d_model={}, features_per_layer={})",
        ref_data.clt_repo, ref_data.d_model, ref_data.n_features_per_layer
    );
    println!("Test cases: {}\n", ref_data.test_cases.len());

    // Open CLT
    let mut clt = CrossLayerTranscoder::open(&ref_data.clt_repo)?;

    let mut total_cases = 0;
    let mut pass_cases = 0;
    let mut total_matches = 0;
    let mut total_compared = 0;

    for tc in &ref_data.test_cases {
        // Create residual tensor from saved values
        let residual = Tensor::from_vec(tc.residual.clone(), (tc.residual.len(),), &device)?;

        // Encode with clt.rs
        clt.load_encoder(tc.layer, &device)?;
        let sparse = clt.encode(&residual, tc.layer)?;

        // Extract Rust top-10 feature indices
        let rust_top10_indices: Vec<usize> = sparse
            .features
            .iter()
            .take(10)
            .map(|(fid, _)| fid.index)
            .collect();

        // Extract reference top-10 feature indices
        let ref_top10_indices: Vec<usize> = tc.top_10.iter().map(|f| f.index).collect();

        // Count matches (set intersection)
        let matches = rust_top10_indices
            .iter()
            .filter(|idx| ref_top10_indices.contains(idx))
            .count();

        let pass = matches >= 8;
        total_cases += 1;
        total_matches += matches;
        total_compared += ref_top10_indices.len().min(10);
        if pass {
            pass_cases += 1;
        }

        println!(
            "Layer {:2}, seed {:3}: {}/{} match ({})  | Rust active: {:5}, Ref active: {:5}",
            tc.layer,
            tc.seed,
            matches,
            ref_top10_indices.len().min(10),
            if pass { "PASS" } else { "FAIL" },
            sparse.len(),
            tc.n_active
        );

        // Check activation magnitudes for matching features
        let mut max_rel_err: f32 = 0.0;
        for ref_feat in &tc.top_10 {
            if let Some((_, rust_act)) = sparse
                .features
                .iter()
                .find(|(fid, _)| fid.index == ref_feat.index)
            {
                let rel_err =
                    (rust_act - ref_feat.activation).abs() / ref_feat.activation.abs().max(1e-10);
                max_rel_err = max_rel_err.max(rel_err);
                if rel_err > 1e-3 {
                    println!(
                        "  WARNING: feature {} activation mismatch: \
                         rust={:.6} ref={:.6} rel_err={:.2e}",
                        ref_feat.index, rust_act, ref_feat.activation, rel_err
                    );
                }
            }
        }
        if max_rel_err <= 1e-3 {
            println!("  Activations: max relative error = {max_rel_err:.2e} (OK)");
        }
    }

    println!("\n{}", "=".repeat(60));
    println!("Result: {pass_cases}/{total_cases} test cases pass (≥8/10 top feature match)");
    println!(
        "Overall: {total_matches}/{total_compared} individual features matched across all cases"
    );

    if pass_cases < total_cases {
        anyhow::bail!("VALIDATION FAILED: only {pass_cases}/{total_cases} cases passed");
    }

    println!("\nAll test cases PASS. CLT encoding matches Python reference.");
    Ok(())
}
